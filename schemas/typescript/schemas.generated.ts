// Generated by ts-to-zod
import { z } from "zod";
import { PostOrderResponseStatus, OrderStatus, SettlementType } from "./types";

export const addressSchema = z
  .string()
  .regex(/^0x([a-fA-F0-9]{40}|0001[a-fA-F0-9]+)$/)
  .describe(
    "Cross-chain compatible address format per EIP-7930. Supports both plain Ethereum addresses\n(0x + 40 hex chars) and version 1 encoded format (0x0001 + chain ID + address) for\nunambiguous cross-chain identification.",
  );

export const amountSchema = z
  .string()
  .regex(/^[0-9]+$/)
  .describe(
    "Token amounts are encoded as decimal strings to preserve precision for large integers\n(e.g., uint256). Always represents the smallest unit of the token (wei for ETH,\nsatoshi for BTC, etc.). No decimals or scientific notation allowed.",
  );

export const swapTypeSchema = z
  .union([z.literal("exact-input"), z.literal("exact-output")])
  .describe(
    'Defines which amount is fixed in a quote request when one amount is undefined.\n- "exact-input": User specifies exact input amount, provider quotes the output amount\n- "exact-output": User specifies exact output amount, provider quotes the input amount needed',
  )
  .default("exact-input");

export const assetLockReferenceSchema = z.object({
  kind: z
    .union([z.literal("the-compact"), z.literal("rhinestone")])
    .describe(
      'The locking protocol to use for securing assets\n- "the-compact": The Compact protocol for efficient cross-chain transfers\n- "rhinestone": Rhinestone modular account abstraction framework',
    ),
  params: z
    .record(
      z
        .unknown()
        .describe(
          "Additional configuration parameters specific to the chosen lock type",
        ),
    )
    .optional()
    .describe(
      "Additional configuration parameters specific to the chosen lock type",
    ),
});

export const originSubmissionSchema = z.object({
  mode: z
    .union([z.literal("user"), z.literal("protocol")])
    .describe(
      'Determines transaction submission responsibility\n- "user": User directly submits and pays gas\n- "protocol": Protocol/relayer submits on user\'s behalf (gasless for user)',
    ),
  schemes: z
    .array(
      z.union([
        z.literal("erc-4337"),
        z.literal("permit2"),
        z.literal("erc20-permit"),
        z.literal("eip-3009"),
      ]),
    )
    .optional()
    .describe(
      'List of supported authorization methods for the transaction\n- "erc-4337": Account abstraction (smart contract wallets)\n- "permit2": Uniswap\'s Permit2 for token approvals\n- "erc20-permit": EIP-2612 permit for gasless approvals\n- "eip-3009": Transfer with authorization (e.g., USDC)',
    ),
});

export const inputSchema = z.object({
  user: addressSchema.describe("The address providing the input assets"),
  asset: addressSchema.describe("The token/asset being provided as input"),
  amount: amountSchema
    .optional()
    .describe(
      "For quote requests:\n- exact-input: The exact amount user will provide (output amount undefined in request)\n- exact-output: Undefined in request (provider quotes required input amount)\nFor direct intents: Always specified",
    ),
  lock: assetLockReferenceSchema
    .optional()
    .describe("Locking mechanism to use for securing the input assets"),
});

export const outputSchema = z.object({
  receiver: addressSchema.describe(
    "The address that will receive the output assets",
  ),
  asset: addressSchema.describe("The token/asset to be received as output"),
  amount: amountSchema
    .optional()
    .describe(
      "For quote requests:\n- exact-input: Undefined in request (provider quotes output amount)\n- exact-output: The exact amount user wants to receive (input amount undefined in request)\nFor direct intents: Always specified",
    ),
  calldata: z
    .string()
    .optional()
    .describe(
      "Encoded function call to be executed when delivering the output,\nenabling composability with other protocols",
    ),
});

export const quotePreferenceSchema = z
  .union([
    z.literal("price"),
    z.literal("speed"),
    z.literal("input-priority"),
    z.literal("trust-minimization"),
  ])
  .describe(
    'Indicates user\'s priority when selecting between multiple quotes\n- "price": Optimize for best exchange rate/lowest cost\n- "speed": Optimize for fastest execution time\n- "input-priority": Prefer quotes that use inputs in the order specified\n- "trust-minimization": Prefer quotes with strongest security guarantees',
  );

export const failureHandlingModeSchema = z
  .union([
    z.literal("refund-automatic"),
    z.literal("refund-claim"),
    z.literal("needs-new-signature"),
  ])
  .describe(
    'Defines how to handle transaction failures or partial fills\n- "refund-automatic": Automatic refund on failure without user action\n- "refund-claim": User must claim refund manually after failure\n- "needs-new-signature": Requires new user signature to retry or refund',
  );

export const getQuoteRequestSchema = z.object({
  user: addressSchema,
  intent: z.object({
    intentType: z.literal("oif-swap"),
    inputs: z.array(inputSchema),
    outputs: z.array(outputSchema),
    swapType: swapTypeSchema
      .optional()
      .describe("Determines which amounts are fixed vs quoted")
      .default("exact-input"),
    minValidUntil: z.number().optional(),
    preference: quotePreferenceSchema.optional(),
    originSubmission: originSubmissionSchema.optional(),
    failureHandling: z.array(failureHandlingModeSchema).optional(),
    partialFill: z.boolean().optional(),
    metadata: z.record(z.any()).optional(),
  }),
  supportedTypes: z.array(z.string()),
});

export const oifEscrowOrderSchema = z.object({
  type: z.literal("oif-escrow-v0"),
  payload: z.object({
    signatureType: z.literal("eip712"),
    domain: z.record(z.any()),
    primaryType: z.string(),
    message: z.record(z.any()),
  }),
});

export const oifResourceLockOrderSchema = z.object({
  type: z.literal("oif-resource-lock-v0"),
  payload: z.object({
    signatureType: z.literal("eip712"),
    domain: z.record(z.any()),
    primaryType: z.string(),
    message: z.record(z.any()),
  }),
});

export const oif3009OrderSchema = z.object({
  type: z.literal("oif-3009-v0"),
  payload: z.object({
    signatureType: z.literal("eip712"),
    domain: z.record(z.any()),
    primaryType: z.string(),
    message: z.record(z.any()),
  }),
  metadata: z.record(z.any()),
});

export const oifGenericOrderSchema = z.object({
  type: z.literal("oif-generic-v0"),
  payload: z.record(z.any()),
});

export const orderSchema = z
  .union([
    oifEscrowOrderSchema,
    oifResourceLockOrderSchema,
    oif3009OrderSchema,
    oifGenericOrderSchema,
  ])
  .describe(
    "Represents all possible order types supported by the OIF protocol.\nEach order type has different security and execution characteristics.",
  );

export const quoteSchema = z.object({
  order: orderSchema,
  validUntil: z.number().optional(),
  eta: z.number().optional(),
  quoteId: z.string().optional(),
  provider: z.string().optional(),
  failureHandling: failureHandlingModeSchema,
  partialFill: z.boolean(),
  metadata: z.record(z.any()).optional(),
});

export const postOrderResponseStatusSchema = z.nativeEnum(
  PostOrderResponseStatus,
);

export const postOrderResponseSchema = z.object({
  orderId: z.string().optional(),
  status: postOrderResponseStatusSchema,
  message: z.string().optional(),
  order: z.record(z.unknown()).optional(),
});

export const orderStatusSchema = z.nativeEnum(OrderStatus);

export const assetAmountSchema = z.object({
  asset: addressSchema.describe(
    "The token/asset identifier, may include chain information",
  ),
  amount: amountSchema
    .optional()
    .describe("Token amount in smallest unit (wei, satoshi, etc.)"),
});

export const settlementTypeSchema = z.nativeEnum(SettlementType);

export const settlementSchema = z.object({
  type: settlementTypeSchema.describe(
    "The type of settlement mechanism used for this order",
  ),
  data: z
    .record(
      z
        .unknown()
        .describe("Additional parameters specific to the settlement type"),
    )
    .describe("Additional parameters specific to the settlement type"),
});

export const getOrderRequestSchema = z.object({
  id: z.string().describe("Unique ID assigned to the order upon submission"),
});

export const getOrderResponseSchema = z.object({
  id: z.string(),
  status: orderStatusSchema,
  createdAt: z.number(),
  updatedAt: z.number(),
  quoteId: z.string().optional(),
  inputAmount: assetAmountSchema,
  outputAmount: assetAmountSchema,
  settlement: settlementSchema,
  fillTransaction: z.record(z.unknown()).optional(),
});

export const getQuoteResponseSchema = z.object({
  quotes: z
    .array(quoteSchema)
    .describe(
      "List of available quotes, may be empty if no quotes are available",
    ),
});
